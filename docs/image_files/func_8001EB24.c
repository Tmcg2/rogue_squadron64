struct _m2c_stack_func_8001EB24 {
    /* 0x000 */ char pad0[0x178];
};                                                  /* size = 0x178 */

s32 func_80024880(s32, u8 *, u32, u32, u32);        /* static */

s32 func_8001EB24(s32 arg0, s32 arg1, u32 arg2, u32 arg3, u8 arg4, u8 **arg5, void *arg6) {
    s16 var_v0_14;
    s32 temp_a0;
    s32 temp_a0_10;
    s32 temp_a0_11;
    s32 temp_a0_12;
    s32 temp_a0_13;
    s32 temp_a0_2;
    s32 temp_a0_3;
    s32 temp_a0_4;
    s32 temp_a0_5;
    s32 temp_a0_6;
    s32 temp_a0_7;
    s32 temp_a0_8;
    s32 temp_a0_9;
    s32 temp_a1_2;
    s32 temp_a1_3;
    s32 temp_a1_5;
    s32 temp_a1_6;
    s32 temp_t4;
    s32 temp_t4_2;
    s32 temp_t4_3;
    s32 temp_t4_4;
    s32 temp_t4_5;
    s32 temp_t4_6;
    s32 temp_t4_7;
    s32 temp_t4_8;
    s32 temp_t4_9;
    s32 temp_t5_10;
    s32 temp_t5_11;
    s32 temp_t5_3;
    s32 temp_t5_4;
    s32 temp_t5_5;
    s32 temp_t5_6;
    s32 temp_t5_7;
    s32 temp_t5_8;
    s32 temp_t5_9;
    s32 temp_t6_3;
    s32 temp_t6_4;
    s32 temp_t6_5;
    s32 temp_t6_6;
    s32 temp_t7;
    s32 temp_t7_2;
    s32 temp_t7_3;
    s32 temp_t7_4;
    s32 temp_v0;
    s32 temp_v0_10;
    s32 temp_v0_11;
    s32 temp_v0_13;
    s32 temp_v0_14;
    s32 temp_v0_15;
    s32 temp_v0_16;
    s32 temp_v0_17;
    s32 temp_v0_18;
    s32 temp_v0_19;
    s32 temp_v0_20;
    s32 temp_v0_22;
    s32 temp_v0_25;
    s32 temp_v0_27;
    s32 temp_v0_2;
    s32 temp_v0_3;
    s32 temp_v0_4;
    s32 temp_v0_6;
    s32 temp_v0_7;
    s32 temp_v0_8;
    s32 temp_v0_9;
    s32 temp_v1;
    s32 temp_v1_2;
    s32 temp_v1_3;
    s32 temp_v1_7;
    s32 temp_v1_9;
    s32 var_s0;
    s32 var_s0_10;
    s32 var_s0_2;
    s32 var_s0_3;
    s32 var_s0_4;
    s32 var_s0_5;
    s32 var_s0_6;
    s32 var_s0_7;
    s32 var_s0_8;
    s32 var_s0_9;
    s32 var_s4;
    s32 var_s4_10;
    s32 var_s4_11;
    s32 var_s4_2;
    s32 var_s4_3;
    s32 var_s4_4;
    s32 var_s4_5;
    s32 var_s4_6;
    s32 var_s4_7;
    s32 var_s4_8;
    s32 var_s4_9;
    s32 var_t0;
    s32 var_t0_10;
    s32 var_t0_11;
    s32 var_t0_12;
    s32 var_t0_13;
    s32 var_t0_14;
    s32 var_t0_2;
    s32 var_t0_3;
    s32 var_t0_4;
    s32 var_t0_5;
    s32 var_t0_6;
    s32 var_t0_7;
    s32 var_t0_8;
    s32 var_t0_9;
    s32 var_t2;
    s32 var_t2_10;
    s32 var_t2_11;
    s32 var_t2_12;
    s32 var_t2_13;
    s32 var_t2_14;
    s32 var_t2_2;
    s32 var_t2_3;
    s32 var_t2_4;
    s32 var_t2_5;
    s32 var_t2_6;
    s32 var_t2_7;
    s32 var_t2_8;
    s32 var_t2_9;
    s32 var_t3;
    s32 var_v0;
    s32 var_v0_10;
    s32 var_v0_11;
    s32 var_v0_13;
    s32 var_v0_15;
    s32 var_v0_16;
    s32 var_v0_18;
    s32 var_v0_20;
    s32 var_v0_2;
    s32 var_v0_4;
    s32 var_v0_5;
    s32 var_v0_6;
    s32 var_v0_7;
    s32 var_v0_8;
    s32 var_v0_9;
    s32 var_v1;
    s8 var_v0_19;
    s8 var_v0_3;
    u32 temp_a1;
    u32 temp_s0;
    u32 temp_s1;
    u32 temp_s2;
    u32 temp_t5;
    u32 temp_t5_2;
    u32 temp_t6;
    u32 temp_t6_2;
    u32 var_a2;
    u32 var_a3;
    u32 var_v0_12;
    u32 var_v0_17;
    u8 **var_a1;
    u8 **var_a1_2;
    u8 **var_a1_3;
    u8 **var_a1_4;
    u8 **var_a1_5;
    u8 **var_a1_6;
    u8 **var_s2;
    u8 **var_s3;
    u8 **var_s3_2;
    u8 **var_s3_3;
    u8 **var_t6;
    u8 *temp_a1_4;
    u8 *temp_t1;
    u8 *temp_t1_2;
    u8 *temp_t1_3;
    u8 *temp_t1_4;
    u8 *temp_t1_5;
    u8 *temp_t1_6;
    u8 *temp_t1_7;
    u8 *temp_t1_8;
    u8 *var_t1;
    u8 *var_t1_10;
    u8 *var_t1_2;
    u8 *var_t1_3;
    u8 *var_t1_4;
    u8 *var_t1_5;
    u8 *var_t1_6;
    u8 *var_t1_7;
    u8 *var_t1_8;
    u8 *var_t1_9;
    u8 temp_v0_21;
    u8 temp_v0_23;
    u8 temp_v0_24;
    u8 temp_v0_5;
    u8 temp_v1_5;
    u8 temp_v1_6;
    u8 temp_v1_8;
    void *temp_v0_12;
    void *temp_v0_26;
    void *temp_v0_28;
    void *temp_v0_29;
    void *temp_v1_4;

    var_a2 = arg2;
    var_a3 = arg3;
    var_t3 = arg0;
    temp_a1 = arg1 & 0xF;
    switch (temp_a1) {
    // Greyscale 4/8 bits per pixel
    case 4:
        // Alpha is embedded with the color values, which implies its 8 bits per pixel
        if (arg1 & 0x8000) {
            var_s0 = (var_a2 + 7) & 0xFFF8;
            temp_v0 = arg4 & 0xFF;
            var_s4 = 0;
            if (temp_v0 > 0) {
                var_t6 = arg5;
                do {
                    var_t1 = *var_t6;
                    temp_v0_2 = var_a3 & 0xFFFF;
                    var_t2 = 0;
                    if (temp_v0_2 > 0) {
                        temp_t4 = var_a2 & 0xFFFF;
                        temp_a1_2 = var_s0 & 0xFFFF;
                        do {
                            var_t0 = 0;
                            temp_a0 = (var_t2 & 1) * 4;
                            if (temp_t4 != 0) {
                                do {
                                    temp_v0_3 = var_t0 ^ temp_a0;
                                    var_t0 += 1;
                                    *(var_t3 + temp_v0_3) = *var_t1; // extract color and alpha value simultaneously
                                    var_t1 += 1;
                                } while (var_t0 < temp_t4);
                            }
                            if (var_t0 < temp_a1_2) {
                                var_v0 = var_t0 ^ temp_a0;
                                do {
                                    *(var_t3 + var_v0) = 0;
                                    var_t0 += 1;
                                    var_v0 = var_t0 ^ temp_a0;
                                } while (var_t0 < temp_a1_2);
                            }
                            var_t2 += 1;
                            var_t3 += temp_a1_2;
                        } while (var_t2 < temp_v0_2);
                    }
                    var_a2 = (u32) (var_a2 & 0xFFFF) >> 1;
                    var_a3 = (u32) (var_a3 & 0xFFFF) >> 1;
                    var_s0 = (((u32) (var_s0 & 0xFFFF) >> 1) + 7) & ~7;
                    var_s4 += 1;
                    var_t6 += 4;
                } while (var_s4 < temp_v0);
                return var_t3;
            }
            goto block_191;
        }
        // Has a transparency color, which implies that its 4 bits per pixel
        if (arg1 & 0x4000) {
            var_s0_2 = (var_a2 + 7) & 0xFFF8;
            temp_v0_4 = arg4 & 0xFF;
            var_s4_2 = 0;
            if (temp_v0_4 > 0) {
                var_s2 = arg5;
                do {
                    var_t1_2 = *var_s2;
                    var_t2_2 = 0;
                    temp_v1 = var_a3 & 0xFFFF;
                    if (temp_v1 > 0) {
                        temp_t4_2 = var_s0_2 & 0xFFFF;
                        do {
                            var_t0_2 = 0;
                            temp_a1_3 = (var_t2_2 & 1) * 4;
                            if (var_a2 & 0xFFFF) {
                                var_v0_2 = 0 & 1;
                                do {
                                    // This if/else is extracting both 4 bit pixels from full byte values
                                    if (var_v0_2 != 0) { // The if is extracting the lower 4 bits and walks the byte-to-read forward by 1
                                        temp_v0_5 = *var_t1_2;
                                        var_t1_2 += 1;
                                        var_v1 = (temp_v0_5 & 0xF) * 0x10; // storing the color value to later check against the transparency color
                                    } else { // the else extracts the upper 4 bits
                                        var_v1 = *var_t1_2 & 0xF0; // storing the color value to later check against the transparency color
                                    }
                                    var_v0_3 = var_v1 & 0xFF;
                                    // Compare color to transparency color. Force alpha to fully opaque if they do not match
                                    if (var_v0_3 != (arg6->unk0 & 0xF0 & 0xFF)) {
                                        var_v0_3 |= 0xF;
                                    }
                                    *(var_t3 + (var_t0_2 ^ temp_a1_3)) = var_v0_3; // store combined color+alpha value, 4 bits for color, 4 bits for alpha
                                    var_t0_2 += 1;
                                    var_v0_2 = var_t0_2 & 1;
                                } while (var_t0_2 < (var_a2 & 0xFFFF));
                            }
                            if (var_t0_2 < temp_t4_2) {
                                var_v0_4 = var_t0_2 ^ temp_a1_3;
                                do {
                                    *(var_t3 + var_v0_4) = 0;
                                    var_t0_2 += 1;
                                    var_v0_4 = var_t0_2 ^ temp_a1_3;
                                } while (var_t0_2 < temp_t4_2);
                            }
                            var_t2_2 += 1;
                            var_t3 += temp_t4_2;
                        } while (var_t2_2 < temp_v1);
                    }
                    var_a2 = (u32) (var_a2 & 0xFFFF) >> 1;
                    var_a3 = (u32) (var_a3 & 0xFFFF) >> 1;
                    var_s0_2 = (((u32) (var_s0_2 & 0xFFFF) >> 1) + 7) & ~7;
                    var_s4_2 += 1;
                    var_s2 += 4;
                } while (var_s4_2 < temp_v0_4);
                return var_t3;
            }
            goto block_191;
        }
        var_s0_3 = (var_a2 + 0xF) & 0xFFF0;
        temp_v0_6 = arg4 & 0xFF;
        var_s4_3 = 0;
        // No transparency color, alpha is always fully opaque, implies 4 bits per pixel
        if (temp_v0_6 > 0) {
            var_s3 = arg5;
            do {
                var_t1_3 = *var_s3;
                temp_v1_2 = var_a3 & 0xFFFF;
                var_t2_3 = 0;
                if (temp_v1_2 > 0) {
                    temp_t7 = var_a2 & 0xFFFF;
                    temp_t6 = var_s0_3 & 0xFFFF;
                    temp_t5 = temp_t6 >> 1;
                    do {
                        temp_a0_2 = (var_t2_3 & 1) * 4;
                        var_t0_3 = 0;
                        if (((s32) (temp_t7 + 1) >> 1) != 0) {
                            do {
                                temp_v0_7 = var_t0_3 ^ (temp_a0_2 & 0xFF);
                                var_t0_3 += 1;
                                *(var_t3 + temp_v0_7) = *var_t1_3; // storing the color values in pairs
                                var_t1_3 += 1;
                            } while (var_t0_3 < ((s32) (temp_t7 + 1) >> 1));
                        }
                        if (var_t0_3 < (s32) temp_t5) {
                            temp_a0_3 = temp_a0_2 & 0xFF;
                            var_v0_5 = var_t0_3 ^ temp_a0_3;
                            do {
                                *(var_t3 + var_v0_5) = 0;
                                var_t0_3 += 1;
                                var_v0_5 = var_t0_3 ^ temp_a0_3;
                            } while (var_t0_3 < (s32) (temp_t6 >> 1));
                        }
                        var_t2_3 += 1;
                        var_t3 += temp_t5;
                    } while (var_t2_3 < temp_v1_2);
                }
                var_a2 = (u32) (var_a2 & 0xFFFF) >> 1;
                var_a3 = (u32) (var_a3 & 0xFFFF) >> 1;
                var_s0_3 = (((u32) (var_s0_3 & 0xFFFF) >> 1) + 0xF) & ~0xF;
                var_s4_3 += 1;
                var_s3 += 4;
            } while (var_s4_3 < temp_v0_6);
            return var_t3;
        }
    default:
block_191:
        return var_t3;
    // CI4 image
    case 0:
        var_s0_4 = (var_a2 + 0xF) & 0xFFF0;
        temp_v0_8 = arg4 & 0xFF;
        // Don't know what's going on in this block
        if (!(var_t3 & 7)) {
            var_s4_4 = 0;
            if (temp_v0_8 > 0) {
                var_s3_2 = arg5;
                do {
                    temp_s2 = var_a3 & 0xFFFF;
                    temp_a1_4 = *var_s3_2;
                    var_s3_2 += 4;
                    var_s4_4 += 1;
                    temp_s1 = var_a2 & 0xFFFF;
                    temp_s0 = var_s0_4 & 0xFFFF;
                    var_t3 = func_80024880(var_t3, temp_a1_4, temp_s1, temp_s0, temp_s2); // presumably this is related to the palette in some capacity?
                    var_a2 = temp_s1 >> 1;
                    var_a3 = temp_s2 >> 1;
                    var_s0_4 = ((temp_s0 >> 1) + 0xF) & ~0xF;
                } while (var_s4_4 < temp_v0_8);
                return var_t3;
            }
            goto block_191;
        }
        // This block looks a bit more normal...
        var_s4_5 = 0;
        if (temp_v0_8 > 0) {
            var_a1 = arg5;
            do {
                var_t1_4 = *var_a1;
                temp_v1_3 = var_a3 & 0xFFFF;
                var_t2_4 = 0;
                if (temp_v1_3 > 0) {
                    temp_t7_2 = var_a2 & 0xFFFF;
                    temp_t6_2 = var_s0_4 & 0xFFFF;
                    temp_t5_2 = temp_t6_2 >> 1;
                    do {
                        var_t0_4 = 0;
                        temp_a0_4 = (var_t2_4 & 1) * 4;
                        if (((s32) (temp_t7_2 + 1) >> 1) != 0) {
                            do {
                                temp_v0_9 = var_t0_4 ^ temp_a0_4;
                                var_t0_4 += 1;
                                *(var_t3 + temp_v0_9) = *var_t1_4; // copying the color indexes in pairs
                                var_t1_4 += 1;
                            } while (var_t0_4 < ((s32) (temp_t7_2 + 1) >> 1));
                        }
                        if (var_t0_4 < (s32) temp_t5_2) {
                            var_v0_6 = var_t0_4 ^ temp_a0_4;
                            do {
                                *(var_t3 + var_v0_6) = 0;
                                var_t0_4 += 1;
                                var_v0_6 = var_t0_4 ^ temp_a0_4;
                            } while (var_t0_4 < (s32) (temp_t6_2 >> 1));
                        }
                        var_t2_4 += 1;
                        var_t3 += temp_t5_2;
                    } while (var_t2_4 < temp_v1_3);
                }
                var_a2 = (u32) (var_a2 & 0xFFFF) >> 1;
                var_a3 = (u32) (var_a3 & 0xFFFF) >> 1;
                var_s0_4 = (((u32) (var_s0_4 & 0xFFFF) >> 1) + 0xF) & ~0xF;
                var_s4_5 += 1;
                var_a1 += 4;
            } while (var_s4_5 < temp_v0_8);
            return var_t3;
        }
        goto block_191;
    // Greyscale 16 bits per pixel
    case 5:
        // Alpha is embedded with the colors
        if (arg1 & 0x8000) {
            var_s0_5 = (var_a2 + 3) & 0xFFFC;
            temp_v0_10 = arg4 & 0xFF;
            var_s4_6 = 0;
            if (temp_v0_10 > 0) {
                var_a1_2 = arg5;
                do {
                    var_t1_5 = *var_a1_2;
                    temp_v0_11 = var_a3 & 0xFFFF;
                    var_t2_5 = 0;
                    if (temp_v0_11 > 0) {
                        temp_t4_3 = var_a2 & 0xFFFF;
                        temp_t5_3 = var_s0_5 & 0xFFFF;
                        do {
                            var_t0_5 = 0;
                            temp_a0_5 = (var_t2_5 & 1) * 2;
                            if (temp_t4_3 != 0) {
                                do {
                                    temp_t1 = var_t1_5 + 1;
                                    temp_v0_12 = var_t3 + ((var_t0_5 ^ temp_a0_5) * 2);
                                    temp_v0_12->unk0 = (u8) *var_t1_5; // extract color
                                    var_t0_5 += 1;
                                    temp_v0_12->unk1 = (u8) *temp_t1; // extract alpha
                                    var_t1_5 = temp_t1 + 1;
                                } while (var_t0_5 < temp_t4_3);
                            }
                            if (var_t0_5 < temp_t5_3) {
                                var_v0_7 = var_t0_5 ^ temp_a0_5;
                                do {
                                    *(var_t3 + (var_v0_7 * 2)) = 0;
                                    var_t0_5 += 1;
                                    var_v0_7 = var_t0_5 ^ temp_a0_5;
                                } while (var_t0_5 < temp_t5_3);
                            }
                            var_t2_5 += 1;
                            var_t3 += temp_t5_3 * 2;
                        } while (var_t2_5 < temp_v0_11);
                    }
                    var_a2 = (u32) (var_a2 & 0xFFFF) >> 1;
                    var_a3 = (u32) (var_a3 & 0xFFFF) >> 1;
                    var_s0_5 = (((u32) (var_s0_5 & 0xFFFF) >> 1) + 3) & ~3;
                    var_s4_6 += 1;
                    var_a1_2 += 4;
                } while (var_s4_6 < temp_v0_10);
                return var_t3;
            }
            goto block_191;
        }
        // Alpha is determined by transparency color
        if (arg1 & 0x4000) {
            var_s0_6 = (var_a2 + 3) & 0xFFFC;
            var_s4_7 = 0;
            if (arg4 != 0) {
                var_a1_3 = arg5;
                do {
                    var_t1_6 = *var_a1_3;
                    temp_v0_13 = var_a3 & 0xFFFF;
                    var_t2_6 = 0;
                    if (temp_v0_13 > 0) {
                        temp_t4_4 = var_a2 & 0xFFFF;
                        temp_t5_4 = var_s0_6 & 0xFFFF;
                        do {
                            var_t0_6 = 0;
                            temp_a0_6 = (var_t2_6 & 1) * 2;
                            if (temp_t4_4 != 0) {
                                do {
                                    temp_v1_4 = var_t3 + ((var_t0_6 ^ temp_a0_6) * 2);
                                    temp_v1_4->unk0 = (u8) *var_t1_6; // extract color
                                    var_t0_6 += 1;
                                    temp_v1_4->unk1 = (s8) -((arg6->unk0 & 0xFF) != *var_t1_6); // fancy-shmancy way to compare the color the the transparency color
                                    var_t1_6 += 1;
                                } while (var_t0_6 < temp_t4_4);
                            }
                            if (var_t0_6 < temp_t5_4) {
                                var_v0_8 = var_t0_6 ^ temp_a0_6;
                                do {
                                    *(var_t3 + (var_v0_8 * 2)) = 0;
                                    var_t0_6 += 1;
                                    var_v0_8 = var_t0_6 ^ temp_a0_6;
                                } while (var_t0_6 < temp_t5_4);
                            }
                            var_t2_6 += 1;
                            var_t3 += temp_t5_4 * 2;
                        } while (var_t2_6 < temp_v0_13);
                    }
                    var_a2 = (u32) (var_a2 & 0xFFFF) >> 1;
                    var_a3 = (u32) (var_a3 & 0xFFFF) >> 1;
                    var_s0_6 = (((u32) (var_s0_6 & 0xFFFF) >> 1) + 3) & 0xFFFC;
                    var_s4_7 += 1;
                    var_a1_3 += 4;
                } while (var_s4_7 < (s32) arg4);
                return var_t3;
            }
            goto block_191;
        }
        var_s0_7 = (var_a2 + 7) & 0xFFF8;
        temp_v0_14 = arg4 & 0xFF;
        var_s4_8 = 0;
        // No alpha value at all, all pixels are fully opaque
        if (temp_v0_14 > 0) {
            var_a1_4 = arg5;
            do {
                var_t1_7 = *var_a1_4;
                temp_v0_15 = var_a3 & 0xFFFF;
                var_t2_7 = 0;
                if (temp_v0_15 > 0) {
                    temp_t5_5 = var_a2 & 0xFFFF;
                    temp_t4_5 = var_s0_7 & 0xFFFF;
                    do {
                        var_t0_7 = 0;
                        temp_a0_7 = (var_t2_7 & 1) * 4;
                        if (temp_t5_5 != 0) {
                            do {
                                temp_v0_16 = var_t0_7 ^ temp_a0_7;
                                var_t0_7 += 1;
                                *(var_t3 + temp_v0_16) = *var_t1_7; // extract color
                                var_t1_7 += 1;
                            } while (var_t0_7 < temp_t5_5);
                        }
                        if (var_t0_7 < temp_t4_5) {
                            var_v0_9 = var_t0_7 ^ temp_a0_7;
                            do {
                                *(var_t3 + var_v0_9) = 0;
                                var_t0_7 += 1;
                                var_v0_9 = var_t0_7 ^ temp_a0_7;
                            } while (var_t0_7 < temp_t4_5);
                        }
                        var_t2_7 += 1;
                        var_t3 += temp_t4_5;
                    } while (var_t2_7 < temp_v0_15);
                }
                var_a2 = (u32) (var_a2 & 0xFFFF) >> 1;
                var_a3 = (u32) (var_a3 & 0xFFFF) >> 1;
                var_s0_7 = (((u32) (var_s0_7 & 0xFFFF) >> 1) + 7) & ~7;
                var_s4_8 += 1;
                var_a1_4 += 4;
            } while (var_s4_8 < temp_v0_14);
            return var_t3;
        }
        goto block_191;
    // CI8 Image
    // Don't see anything that looks like palette handling, which is unexpected
    case 1:
        var_s0_8 = (var_a2 + 7) & 0xFFF8;
        temp_v0_17 = arg4 & 0xFF;
        var_s4_9 = 0;
        if (temp_v0_17 > 0) {
            var_a1_5 = arg5;
            do {
                var_t1_8 = *var_a1_5;
                temp_v0_18 = var_a3 & 0xFFFF;
                var_t2_8 = 0;
                if (temp_v0_18 > 0) {
                    temp_t5_6 = var_a2 & 0xFFFF;
                    temp_t4_6 = var_s0_8 & 0xFFFF;
                    do {
                        var_t0_8 = 0;
                        temp_a0_8 = (var_t2_8 & 1) * 4;
                        if (temp_t5_6 != 0) {
                            do {
                                temp_v0_19 = var_t0_8 ^ temp_a0_8;
                                var_t0_8 += 1;
                                *(var_t3 + temp_v0_19) = *var_t1_8; // copying the color indexes one at a time
                                var_t1_8 += 1;
                            } while (var_t0_8 < temp_t5_6);
                        }
                        if (var_t0_8 < temp_t4_6) {
                            var_v0_10 = var_t0_8 ^ temp_a0_8;
                            do {
                                *(var_t3 + var_v0_10) = 0;
                                var_t0_8 += 1;
                                var_v0_10 = var_t0_8 ^ temp_a0_8;
                            } while (var_t0_8 < temp_t4_6);
                        }
                        var_t2_8 += 1;
                        var_t3 += temp_t4_6;
                    } while (var_t2_8 < temp_v0_18);
                }
                var_a2 = (u32) (var_a2 & 0xFFFF) >> 1;
                var_a3 = (u32) (var_a3 & 0xFFFF) >> 1;
                var_s0_8 = (((u32) (var_s0_8 & 0xFFFF) >> 1) + 7) & ~7;
                var_s4_9 += 1;
                var_a1_5 += 4;
            } while (var_s4_9 < temp_v0_17);
            return var_t3;
        }
        goto block_191;
    // RGBA5551 image
    case 2:
        var_s0_9 = (var_a2 + 3) & 0xFFFC;
        var_s4_10 = 0;
        if (arg4 != 0) {
            var_s3_3 = arg5;
            do {
                var_t1_9 = *var_s3_3;
                temp_v0_20 = var_a3 & 0xFFFF;
                // ALpha is embedded with the colors
                if (arg1 & 0x8000) {
                    var_t2_9 = 0;
                    if (temp_v0_20 > 0) {
                        temp_t6_3 = var_a2 & 0xFFFF;
                        temp_t7_3 = var_s0_9 & 0xFFFF;
                        do {
                            var_t0_9 = 0;
                            temp_t5_7 = (var_t2_9 & 1) * 2;
                            if (temp_t6_3 != 0) {
                                do {
                                    temp_a0_9 = var_t0_9 ^ temp_t5_7;
                                    var_t0_9 += 1;
                                    temp_v0_21 = var_t1_9->unk0;
                                    temp_v1_5 = var_t1_9->unk1;
                                    var_t1_9 += 2;
                                    // This is extrating the color/alpha values, but the way its done suggests that the color type
                                    // is more like ARGB 1555, which doesn't make sense to me
                                    *(var_t3 + (temp_a0_9 * 2)) = (temp_v0_21 >> 7) | ((temp_v0_21 << 9) | (temp_v1_5 * 2));
                                } while (var_t0_9 < temp_t6_3);
                            }
                            if (var_t0_9 < temp_t7_3) {
                                var_v0_11 = var_t0_9 ^ temp_t5_7;
                                do {
                                    *(var_t3 + (var_v0_11 * 2)) = M2C_ERROR(/* Read from unset register $t4 */);
                                    var_t0_9 += 1;
                                    var_v0_11 = var_t0_9 ^ temp_t5_7;
                                } while (var_t0_9 < temp_t7_3);
                            }
                            var_t2_9 += 1;
                            var_t3 += temp_t7_3 * 2;
                        } while (var_t2_9 < temp_v0_20);
                        var_v0_12 = var_a2 & 0xFFFF;
                    } else {
                        goto block_149;
                    }
                } else {
                    // No transparency, alpha is always fully opaque
                    if (!(arg1 & 0x4000)) {
                        temp_v0_22 = var_a3 & 0xFFFF;
                        var_t2_10 = 0;
                        if (temp_v0_22 > 0) {
                            temp_t5_8 = var_a2 & 0xFFFF;
                            temp_t6_4 = var_s0_9 & 0xFFFF;
                            do {
                                var_t0_10 = 0;
                                temp_a1_5 = (var_t2_10 & 1) * 2;
                                if (temp_t5_8 != 0) {
                                    do {
                                        temp_a0_10 = var_t0_10 ^ temp_a1_5;
                                        var_t0_10 += 1;
                                        temp_v0_23 = var_t1_9->unk0;
                                        temp_v1_6 = var_t1_9->unk1;
                                        var_t1_9 += 2;
                                        // This is extrating the color values, but the way its done suggests that the color type
                                        // is more like ARGB 1555 (with the alpha value being ignored here), which doesn't make sense to me
                                        // The `| 1` is the force-to-opaque part
                                        *(var_t3 + (temp_a0_10 * 2)) = (temp_v0_23 << 9) | (temp_v1_6 * 2) | 1;
                                    } while (var_t0_10 < temp_t5_8);
                                }
                                if (var_t0_10 < temp_t6_4) {
                                    var_v0_13 = var_t0_10 ^ temp_a1_5;
                                    do {
                                        *(var_t3 + (var_v0_13 * 2)) = M2C_ERROR(/* Read from unset register $t4 */);
                                        var_t0_10 += 1;
                                        var_v0_13 = var_t0_10 ^ temp_a1_5;
                                    } while (var_t0_10 < temp_t6_4);
                                }
                                var_t2_10 += 1;
                                var_t3 += temp_t6_4 * 2;
                            } while (var_t2_10 < temp_v0_22);
                        }
                        goto block_149;
                    }
                    // 8001F3A8
                    var_t2_11 = 0;
                    temp_v1_7 = var_a3 & 0xFFFF;
                    // Has transparency color
                    if (temp_v1_7 > 0) {
                        temp_t6_5 = var_a2 & 0xFFFF;
                        // Converting the transparency color so we can compare against it later
                        temp_t5_9 = ((((u8) arg6->unk2 >> 2) & 0x3E) | (((arg6->unk0 << 8) & 0xF800) | ((arg6->unk1 * 8) & 0x7C0))) & 0xFFFF;
                        temp_t7_4 = var_s0_9 & 0xFFFF;
                        do {
                            var_t0_11 = 0;
                            temp_a1_6 = (var_t2_11 & 1) * 2;
                            if (temp_t6_5 != 0) {
                                do {
                                    temp_a0_11 = var_t0_11 ^ temp_a1_6;
                                    var_t0_11 += 1;
                                    // This is extrating the color values, but the way its done suggests that the color type
                                    // is more like ARGB 1555 (with the alpha value being ignored here), which doesn't make sense to me
                                    temp_v1_8 = var_t1_9->unk0;
                                    temp_v0_24 = var_t1_9->unk1;
                                    var_t1_9 += 2;
                                    temp_v1_9 = (temp_v1_8 << 9) | (temp_v0_24 * 2);
                                    *(var_t3 + (temp_a0_11 * 2)) = temp_v1_9 | ((temp_v1_9 & 0xFFFF) != temp_t5_9); // compare colors to transparency color, get alpha value from comparison
                                } while (var_t0_11 < temp_t6_5);
                            }
                            // Looks like another comparison to the transparency color, but its not clear what the purpose is
                            var_v0_14 = M2C_ERROR(/* Read from unset register $t4 */) | 1;
                            if ((M2C_ERROR(/* Read from unset register $t4 */) & 0xFFFF) == temp_t5_9) {
                                var_v0_14 = M2C_ERROR(/* Read from unset register $t4 */);
                            }
                            if (var_t0_11 < temp_t7_4) {
                                var_v0_15 = var_t0_11 ^ temp_a1_6;
                                do {
                                    *(var_t3 + (var_v0_15 * 2)) = var_v0_14;
                                    var_t0_11 += 1;
                                    var_v0_15 = var_t0_11 ^ temp_a1_6;
                                } while (var_t0_11 < temp_t7_4);
                            }
                            var_t2_11 += 1;
                            var_t3 += temp_t7_4 * 2;
                        } while (var_t2_11 < temp_v1_7);
                        var_v0_12 = var_a2 & 0xFFFF;
                    } else {
block_149:
                        var_v0_12 = var_a2 & 0xFFFF;
                    }
                }
                var_a2 = var_v0_12 >> 1;
                var_a3 = (u32) (var_a3 & 0xFFFF) >> 1;
                var_s0_9 = (((u32) (var_s0_9 & 0xFFFF) >> 1) + 3) & 0xFFFC;
                var_s4_10 += 1;
                var_s3_3 += 4;
            } while (var_s4_10 < (s32) arg4);
            return var_t3;
        }
        goto block_191;
    // RGBA 32 image
    case 3:
        var_s0_10 = (var_a2 + 3) & 0xFFFC;
        var_s4_11 = 0;
        if (arg4 != 0) {
            var_a1_6 = arg5;
            do {
                var_t1_10 = *var_a1_6;
                temp_v0_25 = var_a3 & 0xFFFF;
                // Alpha value is embedded with the color values
                if (arg1 & 0x8000) {
                    var_t2_12 = 0;
                    if (temp_v0_25 > 0) {
                        temp_t4_7 = var_a2 & 0xFFFF;
                        temp_t5_10 = var_s0_10 & 0xFFFF;
                        do {
                            var_t0_12 = 0;
                            temp_a0_12 = (var_t2_12 & 1) * 2;
                            if (temp_t4_7 != 0) {
                                do {
                                    temp_t1_2 = var_t1_10 + 1;
                                    temp_v0_26 = var_t3 + ((var_t0_12 ^ temp_a0_12) * 4);
                                    temp_v0_26->unk0 = (u8) *var_t1_10; // extracting red
                                    temp_t1_3 = temp_t1_2 + 1;
                                    temp_v0_26->unk1 = (u8) *temp_t1_2; // extracting green
                                    temp_t1_4 = temp_t1_3 + 1;
                                    temp_v0_26->unk2 = (u8) *temp_t1_3; // extracting blue
                                    var_t0_12 += 1;
                                    temp_v0_26->unk3 = (u8) *temp_t1_4; // extracting alpha
                                    var_t1_10 = temp_t1_4 + 1;
                                } while (var_t0_12 < temp_t4_7);
                            }
                            if (var_t0_12 < temp_t5_10) {
                                var_v0_16 = var_t0_12 ^ temp_a0_12;
                                do {
                                    *(var_t3 + (var_v0_16 * 4)) = 0;
                                    var_t0_12 += 1;
                                    var_v0_16 = var_t0_12 ^ temp_a0_12;
                                } while (var_t0_12 < temp_t5_10);
                            }
                            var_t2_12 += 1;
                            var_t3 += temp_t5_10 * 4;
                        } while (var_t2_12 < temp_v0_25);
                        var_v0_17 = var_a2 & 0xFFFF;
                    } else {
                        goto block_189;
                    }
                } else {
                    // No alpha data to extract
                    if (!(arg1 & 0x4000)) {
                        temp_v0_27 = var_a3 & 0xFFFF;
                        var_t2_13 = 0;
                        if (temp_v0_27 > 0) {
                            temp_t4_8 = var_a2 & 0xFFFF;
                            temp_t5_11 = var_s0_10 & 0xFFFF;
                            do {
                                var_t0_13 = 0;
                                temp_a0_13 = (var_t2_13 & 1) * 2;
                                if (temp_t4_8 != 0) {
                                    do {
                                        temp_t1_5 = var_t1_10 + 1;
                                        temp_v0_28 = var_t3 + ((var_t0_13 ^ temp_a0_13) * 4);
                                        temp_v0_28->unk0 = (u8) *var_t1_10; // extracting red
                                        temp_t1_6 = temp_t1_5 + 1;
                                        temp_v0_28->unk1 = (u8) *temp_t1_5; // extracting green
                                        var_t0_13 += 1;
                                        temp_v0_28->unk3 = 0xFF; // Force alpha to fully opaque
                                        temp_v0_28->unk2 = (u8) *temp_t1_6; // extracting blue
                                        var_t1_10 = temp_t1_6 + 1;
                                    } while (var_t0_13 < temp_t4_8);
                                }
                                if (var_t0_13 < temp_t5_11) {
                                    var_v0_18 = var_t0_13 ^ temp_a0_13;
                                    do {
                                        *(var_t3 + (var_v0_18 * 4)) = 0x000000FF;
                                        var_t0_13 += 1;
                                        var_v0_18 = var_t0_13 ^ temp_a0_13;
                                    } while (var_t0_13 < temp_t5_11);
                                }
                                var_t2_13 += 1;
                                var_t3 += temp_t5_11 * 4;
                            } while (var_t2_13 < temp_v0_27);
                        }
                        goto block_189;
                    }
                    var_t2_14 = 0;
                    if (temp_v0_25 > 0) {
                        temp_t6_6 = var_s0_10 & 0xFFFF;
                        do {
                            var_t0_14 = 0;
                            temp_t4_9 = (var_t2_14 & 1) * 2;
                            if (var_a2 & 0xFFFF) {
                                do {
                                    temp_t1_7 = var_t1_10 + 1;
                                    temp_v0_29 = var_t3 + ((var_t0_14 ^ temp_t4_9) * 4);
                                    temp_v0_29->unk0 = (u8) *var_t1_10; // extracting red
                                    temp_t1_8 = temp_t1_7 + 1;
                                    temp_v0_29->unk1 = (u8) *temp_t1_7; // extracting green
                                    var_t1_10 = temp_t1_8 + 1;
                                    temp_v0_29->unk2 = (u8) *temp_t1_8; // extracting blue
                                    // Compare red/green/blue to the transparency color
                                    // If it matches, force alpha to fully transparent, other force to fully opaque
                                    if ((var_t1_10->unk0 != (arg6->unk0 & 0xFF)) || ((var_v0_19 = 0xFF, (var_t1_10->unk1 == (arg6->unk1 & 0xFF))) && (var_v0_19 = 0, (var_t1_10->unk2 != (arg6->unk2 & 0xFF))))) {
                                        var_v0_19 = 0xFF;
                                    }
                                    *(temp_v0_29 + 3) = var_v0_19;
                                    var_t0_14 += 1;
                                } while (var_t0_14 < (var_a2 & 0xFFFF));
                            }
                            if (var_t0_14 < temp_t6_6) {
                                var_v0_20 = var_t0_14 ^ temp_t4_9;
                                do {
                                    *(var_t3 + (var_v0_20 * 4)) = 0;
                                    var_t0_14 += 1;
                                    var_v0_20 = var_t0_14 ^ temp_t4_9;
                                } while (var_t0_14 < temp_t6_6);
                            }
                            var_t2_14 += 1;
                            var_t3 += temp_t6_6 * 4;
                        } while (var_t2_14 < (var_a3 & 0xFFFF));
                        var_v0_17 = var_a2 & 0xFFFF;
                    } else {
block_189:
                        var_v0_17 = var_a2 & 0xFFFF;
                    }
                }
                var_a2 = var_v0_17 >> 1;
                var_a3 = (u32) (var_a3 & 0xFFFF) >> 1;
                var_s0_10 = (((u32) (var_s0_10 & 0xFFFF) >> 1) + 3) & 0xFFFC;
                var_s4_11 += 1;
                var_a1_6 += 4;
            } while (var_s4_11 < (s32) arg4);
        }
        goto block_191;
    }
}
